#!/usr/bin/python3
"""
Command line tool to compile one or more template text files into a
single importable python source file.
"""

from __future__ import annotations

import importlib
import os
import sys
from argparse import ArgumentParser, Namespace
from ast import literal_eval
from pathlib import Path
from tempfile import NamedTemporaryFile
from typing import IO, Any

from .compiler import compile

PROG = Path(__file__).stem

TEMPLATE_HEADER = f"""
#!/usr/bin/env python3
# This file is autogenerated by {PROG}
""".lstrip()

TEMPLATE_FOOTER = """
class Template_Namespace:
    def __init__(self, args):
        self._dict = args

    def __getattr__(self, val):
        return self._dict.get(val)

class Template:
    def __init__(self, name):
        x = name.rfind('.')
        self.func = _templates.get(name if x < 0 else name[:x])
        if not self.func:
            raise ValueError(f'No template "{name}"')

    def generate(self, *args, **kwargs):
        return self.func(Template_Namespace(dict(*args, **kwargs)))

    def render(self, *args, **kwargs):
        return ''.join(self.func(Template_Namespace(dict(*args, **kwargs))))
"""


def get_title(desc: str) -> str:
    "Return single title line from description"
    res = []
    for line in desc.splitlines():
        line = line.strip()
        res.append(line)
        if line.endswith('.'):
            return ' '.join(res)

    sys.exit(f'Must end description "{desc}" with a full stop.')


def try_eval(val: str) -> Any:
    "Try to evaluate a value. If it fails, evaluate it as a string"
    try:
        return literal_eval(val)
    except (ValueError, SyntaxError):
        pass

    return literal_eval(f'"{val}"')


def write(files: list[Path], out: IO, logout: str) -> None:
    out.write(TEMPLATE_HEADER)
    names = []
    for index, file in enumerate(files):
        if logout:
            print(f'Compiling {file} to {logout} ..')

        out.write(f'\n# file "{file.name}"\n')
        funcname = f'_template_{index}'
        compile(file, out, funcname)
        names.append(f"    '{file.stem}': {funcname},")

    out.write('\n_templates = {\n' + '\n'.join(names) + '\n}\n')
    out.write(TEMPLATE_FOOTER)


def writefile(files: list[Path], outpath: Path | None, logout: str) -> None:
    if not outpath:
        write(files, sys.stdout, logout)
        return

    with NamedTemporaryFile(
        'w+t', dir=outpath.parent, prefix=f'.{PROG}-', suffix=outpath.suffix
    ) as tmp:
        write(files, tmp, logout)
        tmp.flush()
        tmppath = Path(tmp.name)

        # Set permissions as per user default
        umask = os.umask(0o666)
        os.umask(umask)
        tmppath.chmod(0o666 & ~umask)

        tmppath.replace(outpath)


def import_file(file: Path) -> Any:
    "Import a Python file"
    spec = importlib.util.spec_from_file_location(  # type: ignore
        file.stem, file
    )
    module = importlib.util.module_from_spec(spec)  # type: ignore
    spec.loader.exec_module(module)
    return module


def main() -> str | None:
    "Main code"
    # Parse arguments
    opt = ArgumentParser(description=__doc__)
    cmd = opt.add_subparsers(title='Commands', dest='cmdname')

    # Add each command ..
    for name in globals():
        if not name[0].islower() or not name.endswith('_'):
            continue

        cls = globals()[name]
        name = name[:-1]

        if hasattr(cls, 'doc'):
            desc = cls.doc.strip()
        elif cls.__doc__:
            desc = cls.__doc__.strip()
        else:
            return f'Must define a docstring for command class "{name}".'

        title = get_title(desc)
        cmdopt = cmd.add_parser(name, description=desc, help=title, aliases=[name[0]])

        # Set up this commands own arguments, if it has any
        if hasattr(cls, 'init'):
            cls.init(cmdopt)

        # Set the function to call
        cmdopt.set_defaults(func=cls.run, name=name, parser=cmdopt)

    args = opt.parse_args()

    if 'func' not in args:
        opt.print_help()
        return None

    return args.func(args)


class compile_:
    "Compile one or more template files into a single Python source file."

    @staticmethod
    def init(parser: ArgumentParser) -> None:
        parser.add_argument('-o', '--outfile', help='output file, default is stdout')
        parser.add_argument(
            '-w',
            '--watch',
            action='store_true',
            help='watch specified files forever and run on any change',
        )
        parser.add_argument(
            '-q',
            '--quiet',
            action='store_true',
            help='do not print any informational messages',
        )
        parser.add_argument('template_file', nargs='+', help='input template file[s]')

    @staticmethod
    def run(args: Namespace) -> str | None:
        files = [Path(p) for p in args.template_file]
        if not files:
            return 'No files specified.'

        # Check each file can be read and ensure no duplicate names
        names: dict[str, Path] = {}
        for file in files:
            if not file.is_file():
                return f'File not found: {file}'

            other = names.get(file.stem)
            if other:
                return f'Error: "{other}" file name same as "{file}".'

            names[file.stem] = file

        if args.outfile and args.outfile != '-':
            outpath = Path(args.outfile)
            if not outpath.suffix:
                outpath = outpath.with_suffix('.py')
            logout = '' if args.quiet else str(outpath)
        else:
            outpath = None
            logout = ''

        writefile(files, outpath, logout)

        if args.watch:
            from .watcher import Watcher

            watcher = Watcher(files, log_changes=True)
            while True:
                print('Waiting for changes ...')
                watcher.wait_for_change()
                writefile(files, outpath, logout)

        return None


class render_:
    "Render given templates + arguments to output, for exercising/testing."

    @staticmethod
    def init(parser: ArgumentParser) -> None:
        parser.add_argument(
            '-d',
            '--delineate',
            action='store_true',
            help='delineate chunks with "|" in generated output',
        )
        parser.add_argument('template_file', help='python template file')
        parser.add_argument('template_name', help='name of template to render')
        parser.add_argument('args', nargs='*', help='arguments for template')

    @staticmethod
    def run(args: Namespace) -> str | None:
        tfile = Path(args.template_file)
        if not tfile.is_file():
            return f'File not found: "{tfile}"'

        mod = import_file(tfile)
        end = '|' if args.delineate else ''
        argsvals = {}
        for arg in args.args:
            if '=' not in arg:
                return f'Argument "{arg}" must be in the form key=value'

            key, val = arg.split('=', 1)
            argsvals[key] = try_eval(val)

        for out in mod.Template(args.template_name).generate(argsvals):
            print(out, end=end)

        return None


if __name__ == '__main__':
    sys.exit(main())

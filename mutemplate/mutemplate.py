#!/usr/bin/python3
'''
Command line tool to compile one or more template text files into a
single importable python source file.
'''
from __future__ import annotations

import importlib
import os
import re
import sys
from argparse import ArgumentParser, Namespace
from ast import literal_eval
from pathlib import Path
from tempfile import NamedTemporaryFile
from typing import IO, Any, Iterable, Iterator

from .compiler import compile

PROG = Path(__file__).stem

TEMPLATE_HEADER = f'''
#!/usr/bin/env python3
# This file is autogenerated by {PROG}
'''.lstrip()

class COMMAND:
    'Base class for all commands'
    commands = []  # type: ignore

    @classmethod
    def add(cls, parent) -> None:
        'Append parent command to internal list'
        cls.commands.append(parent)

def get_title(desc: str) -> str:
    'Return single title line from description'
    res = []
    for line in desc.splitlines():
        line = line.strip()
        res.append(line)
        if line.endswith('.'):
            return ' '. join(res)

    sys.exit(f'Must end description "{desc}" with a full stop.')

def try_eval(val: str) -> Any:
    'Try to evaluate a value. If it fails, evaluate it as a string'
    try:
        return literal_eval(val)
    except ValueError:
        pass

    return literal_eval(f'"{val}"')

def write(files: list[Path], out: IO, template_body: str, logout: str) -> None:
    out.write(TEMPLATE_HEADER)
    names = []
    for index, file in enumerate(files):
        if logout:
            print(f'Compiling {file} to {logout} ..')

        out.write(f'\n# file "{file.name}"\n')
        funcname = f'_template_{index}'
        compile(file, out, funcname)
        names.append(f'    \'{file.stem}\': {funcname},')

    out.write('\n_templates = {\n' + '\n'.join(names) + '\n}\n')
    out.write(template_body)

def writefile(files: list[Path], outpath: Path | None,
              template_body: str, logout: str) -> None:
    if not outpath:
        write(files, sys.stdout, template_body, logout)
        return

    with NamedTemporaryFile('w+t', dir=outpath.parent, prefix=f'.{PROG}-',
                            suffix=outpath.suffix) as tmp:
        write(files, tmp, template_body, logout)
        tmp.flush()
        tmppath = Path(tmp.name)

        # Set permissions as per user default
        umask = os.umask(0o666)
        os.umask(umask)
        tmppath.chmod(0o666 & ~umask)

        tmppath.replace(outpath)

def import_file(file: Path) -> Any:
    'Import a Python file'
    spec = importlib.util.spec_from_file_location(  # type: ignore
            file.stem, str(file))
    module = importlib.util.module_from_spec(spec)  # type: ignore
    spec.loader.exec_module(module)
    return module

def main() -> str | None:
    'Main code'
    # Parse arguments
    opt = ArgumentParser(description=__doc__)
    cmd = opt.add_subparsers(title='Commands', dest='cmdname')

    # Add each command ..
    for cls in COMMAND.commands:
        name = cls.__name__[1:]
        if hasattr(cls, 'doc'):
            desc = cls.doc.strip()
        elif cls.__doc__:
            desc = cls.__doc__.strip()
        else:
            return f'Must define a docstring for command class "{name}".'

        title = get_title(desc)
        cmdopt = cmd.add_parser(name, description=desc, help=title,
                                aliases=[name[0]])

        # Set up this commands own arguments, if it has any
        if hasattr(cls, 'init'):
            cls.init(cmdopt)

        # Set the function to call
        cmdopt.set_defaults(func=cls.run, name=name, parser=cmdopt)

    args = opt.parse_args()

    if 'func' not in args:
        opt.print_help()
        return None

    args.basedir = Path(__file__).parent
    return args.func(args)

def recurse(paths: Iterable[Path]) -> Iterator[Path]:
    'Recursively yield files from a list of files and directories'
    for path in paths:
        if path.is_dir():
            yield from recurse(path.iterdir())
        else:
            yield path

@COMMAND.add
class _compile(COMMAND):
    'Compile one or more template files into a single Python source file.'
    @staticmethod
    def init(parser: ArgumentParser) -> None:
        parser.add_argument('-o', '--outfile',
                            help='output file, default is stdout')
        parser.add_argument('-w', '--watch', action='store_true',
                            help='watch specified files forever and '
                            'run on any change')
        parser.add_argument('-q', '--quiet', action='store_true',
                            help='do not print any informational messages')
        parser.add_argument('template_file', nargs='+',
                            help='input template file[s] '
                            '(or dir[s] containing template file[s])')

    @staticmethod
    def run(args: Namespace) -> str | None:
        files = list(dict.fromkeys(recurse(Path(p)
                                           for p in args.template_file)))
        if not files:
            return 'No files specified.'

        for file in files:
            if not file.is_file():
                return f'File not found: {file}'

        if args.outfile and args.outfile != '-':
            outpath = Path(args.outfile)
            if not outpath.suffix:
                outpath = outpath.with_suffix('.py')
            logout = '' if args.quiet else str(outpath)
        else:
            outpath = None
            logout = ''

        # Read the template body. We put it in a separate file so that
        # we can edit the template as a Pythog file with syntax
        # highlighting etc.
        template_body = (args.basedir / 'template_body_py.txt').read_text()
        template_body = re.sub(r'^.*### TEMPLATE_START', '',
                               template_body, flags=re.DOTALL)

        writefile(files, outpath, template_body, logout)

        if args.watch:
            from .watcher import Watcher
            watcher = Watcher(files, log_changes=True)
            while True:
                print("Waiting for changes ...")
                watcher.wait_for_change()
                writefile(files, outpath, template_body, logout)

        return None

@COMMAND.add
class _render(COMMAND):
    'Render given templates + arguments to output, for exercising/testing.'
    @staticmethod
    def init(parser: ArgumentParser) -> None:
        parser.add_argument('-d', '--delineate', action='store_true',
                            help='delineate chunks with "|" in generated '
                            'output')
        parser.add_argument('template_file',
                            help='python template file')
        parser.add_argument('template_name',
                            help='name of template to render')
        parser.add_argument('args', nargs='*',
                            help='arguments for template')

    @staticmethod
    def run(args: Namespace) -> str | None:
        tfile = Path(args.template_file)
        if not tfile.is_file():
            return f'File not found: "{tfile}"'

        mod = import_file(tfile)
        end = '|' if args.delineate else ''
        argsvals = {}
        for arg in args.args:
            if '=' not in arg:
                return f'Argument "{arg}" must be in the form key=value'

            key, val = arg.split('=', 1)
            argsvals[key] = try_eval(val)

        for out in mod.Template(args.template_name).generate(argsvals):
            print(out, end=end)

        return None

if __name__ == '__main__':
    sys.exit(main())
